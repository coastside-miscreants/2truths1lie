/**
 * Two Truths & AI Game - Frontend JavaScript
 * 
 * This script implements the client-side logic for the "2 Truths and a Lie" game.
 * It handles:
 * - Connecting to the server via Server-Sent Events (SSE)
 * - Displaying game rounds (statements)
 * - Handling user interactions
 * - Showing feedback and scoring
 * - Managing game state
 * 
 * The game challenges users to identify which of three statements is a lie
 * generated by Claude AI.
 */

document.addEventListener("DOMContentLoaded", () => {
    console.log("DOM fully loaded and parsed");

    // --- DOM Element References ---
    // Get references to all UI elements needed for game interaction
    const statementsContainer = document.getElementById("statements-container");
    const feedbackArea = document.getElementById("feedback-area");
    const feedbackText = document.getElementById("feedback-text");
    const explanationsContainer = document.getElementById("explanations");
    const nextRoundButton = document.getElementById("next-round-button");
    const correctScoreSpan = document.getElementById("correct-score");
    const incorrectScoreSpan = document.getElementById("incorrect-score");
    const roundsPlayedSpan = document.getElementById("rounds-played");
    const flashFeedback = document.getElementById("flash-feedback"); // Element for flashy animations
    
    // --- Dynamically Add Loading Indicator Styles ---
    // Add the CSS for loading indicator programmatically to keep it with related code
    const loadingStyles = document.createElement("style");
    loadingStyles.textContent = `
        .loading-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--accent-blue);
            padding: 30px 20px;
            font-family: "Bangers", cursive;
            letter-spacing: 1px;
        }
        
        .loading-content p {
            margin-top: 15px;
            font-size: 1.3em;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(29, 53, 87, 0.3);
            border-radius: 50%;
            border-top-color: var(--accent-blue);
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .statement-placeholder.error {
            color: var(--secondary-red);
            font-weight: bold;
            border: 2px dashed var(--secondary-red);
            border-radius: 5px;
            background-color: rgba(249, 87, 56, 0.1);
            padding: 20px;
        }
    `;
    document.head.appendChild(loadingStyles);

    console.log("DOM elements retrieved");

    // --- Game State Variables ---
    // These variables track the current state of the game
    let currentStatements = [];    // The current set of statements being displayed
    let correctScore = 0;          // Number of correct guesses
    let incorrectScore = 0;        // Number of incorrect guesses
    let roundsPlayed = 0;          // Total rounds played
    let gameInProgress = false;    // Flag to prevent multiple clicks during feedback
    let eventSource = null;        // SSE connection for real-time updates

    console.log("Initial game state set");

    // --- Core Functions ---
    
    /**
     * Establishes a Server-Sent Events (SSE) connection to receive game updates
     * from the server in real-time. Sets up event handlers for connection events,
     * incoming messages, and error handling.
     */
    function connectSSE() {
        console.log("Attempting to connect to SSE endpoint...");
        
        // Close any existing connection before creating a new one
        if (eventSource) {
            console.log("Closing existing SSE connection.");
            eventSource.close();
        }
        
        // No need to specify port - browser automatically uses current host/port
        const baseUrl = '';
            
        // Create new SSE connection to the game stream endpoint
        eventSource = new EventSource(`${baseUrl}/api/game_stream`);

        // Handle successful connection establishment
        eventSource.onopen = function() {
            console.log("SSE connection opened successfully.");
            // Game automatically starts on server when client connects
            
            // Prepare UI for incoming round
            showLoadingIndicator();
            feedbackArea.classList.add("hidden");
            nextRoundButton.classList.add("hidden");
            flashFeedback.classList.add("hidden");
            flashFeedback.classList.remove("flashing", "flash-correct", "flash-incorrect");
            gameInProgress = true;
            console.log("Waiting for server to automatically generate first round...");
        };

        // Handle incoming messages from the server
        eventSource.onmessage = function(event) {
            console.log("SSE message received:", event.data);
            try {
                // Parse the JSON message from the server
                const data = JSON.parse(event.data);
                
                // Handle different message types
                if (data.type === "new_round") {
                    // New game round received
                    handleNewRoundData(data.payload);
                } else if (data.type === "error") {
                    // Error message received
                    handleServerError(data.message);
                } else {
                    // Unknown message type
                    console.warn("Received unknown SSE message type:", data.type);
                }
            } catch (error) {
                // Error parsing the message
                console.error("Error parsing SSE message:", error, "Raw data:", event.data);
                handleServerError("Received invalid data from server.");
            }
        };

        // Handle connection errors
        eventSource.onerror = function(error) {
            console.error("SSE connection error:", error);
            statementsContainer.innerHTML = 
                `<div class="statement-placeholder error">Connection to game server lost. Please refresh the page to try again.</div>`;
            gameInProgress = false;
            if (eventSource) eventSource.close();
        };
    }

    /**
     * Displays a loading indicator with spinner while waiting for server response.
     * This provides visual feedback that something is happening.
     */
    function showLoadingIndicator() {
        console.log("Showing Claude API loading indicator");
        statementsContainer.innerHTML = `
            <div class="loading-content">
                <div class="spinner"></div>
                <p>The gerbils in F*ckchops mind are thinking hard...</p>
            </div>
        `;
    }
    
    /**
     * Hides the loading indicator when content is ready.
     * This is a no-op function since we replace the entire container content.
     */
    function hideLoadingIndicator() {
        console.log("Hiding Claude API loading indicator");
        // No action needed as we'll replace the content entirely
    }

    /**
     * Requests a new round from the server by making an API call.
     * Shows a loading indicator while waiting for the response.
     */
    function requestNewRound() {
        console.log("Requesting new round from server...");
        
        // Reset UI for a new round
        feedbackArea.classList.add("hidden");
        nextRoundButton.classList.add("hidden");
        flashFeedback.classList.add("hidden");
        flashFeedback.classList.remove("flashing", "flash-correct", "flash-incorrect");
        gameInProgress = true;
        
        // Show loading indicator while waiting for server response
        showLoadingIndicator();

        // Make API request to trigger generation of a new round
        fetch("/api/trigger_new_round")
            .then(response => {
                // Check if the request was successful
                if (!response.ok) {
                    console.error("Failed to trigger new round generation on server.");
                    statementsContainer.innerHTML = `
                        <div class="statement-placeholder error">Failed to trigger new round generation. Please try again.</div>
                    `;
                }
                // Actual data will come via SSE, not this response
            })
            .catch(error => {
                // Handle connection errors
                console.error("Error triggering new round:", error);
                statementsContainer.innerHTML = `
                    <div class="statement-placeholder error">Error connecting to server: ${error.message}</div>
                `;
            });
    }

    /**
     * Processes a new round of statements received from the server.
     * Validates the data format and displays the statements to the user.
     * 
     * @param {Object} data - The round data containing statements
     */
    function handleNewRoundData(data) {
        console.log("Processing new round data:", data);
        
        // Hide the loading indicator
        hideLoadingIndicator();
        
        // Validate the data format
        if (!data.statements || data.statements.length !== 3) {
            console.error("Invalid new round data format received:", data);
            handleServerError("Received invalid round data from server.");
            return;
        }
        
        // Store the statements and display them
        currentStatements = data.statements;
        displayStatements();
    }

    /**
     * Handles errors received from the server or client-side processing.
     * Displays an error message to the user.
     * 
     * @param {string} errorMessage - The error message to display
     */
    function handleServerError(errorMessage) {
        console.error("Server error reported:", errorMessage);
        
        // Hide the loading indicator
        hideLoadingIndicator();
        
        // Display error message to user
        statementsContainer.innerHTML = 
            `<div class="statement-placeholder error">Oops! Couldn't load the next round. Server error: ${errorMessage}</div>`;
        gameInProgress = false;
    }

    /**
     * Displays the statements to the user as interactive buttons.
     * Shuffles the statements to randomize the order.
     * Creates overlay elements for feedback after selection.
     */
    function displayStatements() {
        console.log("Displaying statements:", currentStatements);
        
        // Clear the container
        statementsContainer.innerHTML = "";
        
        // Shuffle the statements for random order
        window.displayedStatementOrder = [...currentStatements].sort(() => Math.random() - 0.5);
        console.log("Shuffled statements for display:", window.displayedStatementOrder);

        // Create and add button for each statement
        window.displayedStatementOrder.forEach((statement) => {
            // Create container for button and overlay
            const buttonContainer = document.createElement("div");
            buttonContainer.classList.add("statement-container");
            buttonContainer.style.position = "relative"; // For positioning the overlay
            
            // Create button with statement text
            const button = document.createElement("button");
            button.classList.add("statement-button");
            button.textContent = statement.text;
            button.dataset.statementText = statement.text; // Store for reference
            button.addEventListener("click", handleStatementClick);
            
            // Create overlay for feedback (shown after selection)
            const overlay = document.createElement("div");
            overlay.classList.add("statement-overlay");
            overlay.style.position = "absolute";
            overlay.style.top = "0";
            overlay.style.left = "0";
            overlay.style.width = "100%";
            overlay.style.height = "100%";
            overlay.style.display = "flex";
            overlay.style.justifyContent = "center";
            overlay.style.alignItems = "center";
            overlay.style.borderRadius = "5px";
            overlay.style.opacity = "0"; // Hidden initially
            overlay.style.transition = "opacity 0.3s ease";
            overlay.style.pointerEvents = "none"; // Don't block button clicks
            overlay.style.zIndex = "5";
            overlay.style.textTransform = "uppercase";
            overlay.style.fontFamily = '"Bangers", cursive';
            overlay.style.fontSize = "2.5em";
            overlay.style.color = "var(--primary-yellow)";
            overlay.style.textShadow = "2px 2px 0px var(--neutral-black)";
            
            // Add button and overlay to container
            buttonContainer.appendChild(button);
            buttonContainer.appendChild(overlay);
            statementsContainer.appendChild(buttonContainer);
        });
        console.log("Statement buttons added to DOM.");
    }

    /**
     * Displays a flashing message with animated feedback about the user's guess.
     * Shows a comic-book style "POW!" effect with different messages based on correctness.
     * 
     * @param {boolean} isCorrect - Whether the user's guess was correct
     */
    function triggerFlashFeedback(isCorrect) {
        // Select message and style based on correctness
        const message = isCorrect ? "You are smart AF!" : "You are dumb AF!";
        const cssClass = isCorrect ? "flash-correct" : "flash-incorrect";
        console.log(`Triggering flash feedback: ${message}`);

        // Set the message text
        flashFeedback.textContent = message;
        
        // Reset classes before adding new ones (for clean animation)
        flashFeedback.className = "hidden"; // Start hidden
        
        // Use requestAnimationFrame for smoother animation transition
        requestAnimationFrame(() => {
            flashFeedback.classList.remove("hidden");
            flashFeedback.classList.add(cssClass, "flashing");
        });

        // Hide the feedback after animation completes
        setTimeout(() => {
            flashFeedback.classList.remove("flashing");
            flashFeedback.classList.add("hidden"); 
            console.log("Flash feedback animation complete.");
        }, 3000); // 3 seconds total duration
    }

    /**
     * Shows feedback on a statement button by displaying an overlay
     * indicating whether it was correct or incorrect.
     * 
     * @param {HTMLElement} button - The button element to show feedback on
     * @param {boolean} isCorrect - Whether this statement's assessment was correct
     */
    function showStatementFeedback(button, isCorrect) {
        // Find the button's parent container and the overlay
        const container = button.parentElement;
        const overlay = container.querySelector(".statement-overlay");
        
        // Configure the overlay content and styling
        overlay.textContent = isCorrect ? "CORRECT!" : "WRONG!";
        overlay.className = "statement-overlay " + (isCorrect ? "correct" : "incorrect");
        
        // Set background colors based on correctness
        if (isCorrect) {
            overlay.style.backgroundColor = "rgba(40, 167, 69, 0.85)"; // Green with opacity
        } else {
            overlay.style.backgroundColor = "rgba(249, 87, 56, 0.85)"; // Red with opacity
        }
        
        // Show the overlay by changing opacity
        overlay.style.opacity = "1";
    }

    /**
     * Handles the user's click on a statement button.
     * Processes the selection, updates scores, and shows feedback.
     * 
     * @param {Event} event - The click event object
     */
    function handleStatementClick(event) {
        console.log("Statement button clicked:", event.target.textContent);
        
        // Ignore clicks if game is not in progress
        if (!gameInProgress) {
            console.warn("Statement clicked but game is not in progress. Ignoring.");
            return;
        }

        // Update game state
        gameInProgress = false;
        roundsPlayed++;
        console.log(`Round ${roundsPlayed} ended.`);

        // Find the selected statement data
        const selectedButton = event.target;
        const selectedText = selectedButton.dataset.statementText;
        const selectedStatement = currentStatements.find(s => s.text === selectedText);

        if (!selectedStatement) {
            console.error("Could not find selected statement data for text:", selectedText);
            return;
        }
        console.log("Selected statement object:", selectedStatement);

        // Disable all buttons and highlight the selected one
        document.querySelectorAll(".statement-button").forEach(btn => {
            btn.disabled = true;
            btn.style.cursor = "default";
            if (btn === selectedButton) {
                btn.style.borderWidth = "4px"; // Highlight the selected button
                console.log("Highlighting selected button.");
            }
        });
        console.log("All statement buttons disabled.");

        // Determine if the selection was correct and update score
        let wasCorrect = false;
        if (selectedStatement.isLie) {
            // User correctly identified the lie
            console.log("Correct guess!");
            feedbackText.textContent = "Correct! You found the lie!";
            feedbackText.className = "correct";
            correctScore++;
            wasCorrect = true;
        } else {
            // User incorrectly identified a truth as a lie
            console.log("Incorrect guess.");
            feedbackText.textContent = "Incorrect! That was actually true.";
            feedbackText.className = "incorrect";
            incorrectScore++;
            wasCorrect = false;
        }

        // Show feedback on the selected button
        showStatementFeedback(selectedButton, wasCorrect);

        // Show feedback on other buttons (reveal the lie if user picked wrong)
        document.querySelectorAll(".statement-button").forEach(btn => {
            if (btn !== selectedButton) {
                const btnText = btn.dataset.statementText;
                const statement = currentStatements.find(s => s.text === btnText);
                if (statement && statement.isLie) {
                    // If this was the lie and user picked something else, highlight it
                    showStatementFeedback(btn, true); // This was the actual lie
                }
            }
        });

        // Display the animated feedback message
        triggerFlashFeedback(wasCorrect);

        // Show explanations and update the score
        displayExplanations();
        updateScoreboard();

        // Show feedback area and next round button
        feedbackArea.classList.remove("hidden");
        nextRoundButton.classList.remove("hidden");
        console.log("Feedback and next round button displayed.");
    }

    /**
     * Displays explanations for all statements, showing why each is true or false.
     * Uses the same order as the displayed statements for consistency.
     */
    function displayExplanations() {
        console.log("Displaying explanations.");
        explanationsContainer.innerHTML = "";
        
        // Create explanation elements for each statement in the same order they were displayed
        window.displayedStatementOrder.forEach(statement => {
            const p = document.createElement("p");
            const explanationClass = statement.isLie ? "false-explanation" : "true-explanation";
            const type = statement.isLie ? "Lie" : "Truth";
            
            // Apply styling and content
            p.classList.add(explanationClass);
            p.innerHTML = `<strong>${type}:</strong> ${statement.text}<br><em>${statement.explanation}</em>`;
            explanationsContainer.appendChild(p);
        });
    }

    /**
     * Updates the scoreboard with current game statistics.
     * Shows correct/incorrect guesses and total rounds played.
     */
    function updateScoreboard() {
        console.log(`Updating scoreboard: Correct=${correctScore}, Incorrect=${incorrectScore}, Rounds=${roundsPlayed}`);
        correctScoreSpan.textContent = correctScore;
        incorrectScoreSpan.textContent = incorrectScore;
        roundsPlayedSpan.textContent = roundsPlayed;
    }

    // --- Event Listeners ---
    
    // Set up next round button click handler
    nextRoundButton.addEventListener("click", () => {
        console.log("Next Round button clicked.");
        requestNewRound();
    });

    // --- Initial Game Setup ---
    console.log("Initiating SSE connection...");
    
    // Show the loading indicator while waiting for initial round
    showLoadingIndicator();
    
    // Connect to server to start the game
    connectSSE(); 
});